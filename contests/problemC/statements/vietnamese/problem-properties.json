{"scoring":null,"notes":"\\begin{itemize}\r\n  \\item Có thể có nhiều tiến trình cùng nằm trên một hàng hoặc một cột.\r\n  \\item Nếu một miền trống, số tiến trình của miền đó được tính là $0$.\r\n  \\item Nếu $n = 0$ thì đáp án bằng $0$.\r\n  \\item Đường cắt có thể đặt ở bất kỳ khoảng trống nào giữa hai hàng/cột liên tiếp miễn là vẫn còn hàng/cột ở cả hai phía.\r\n\\item \\textbf{Bắt buộc:} Cổng Fenrir chỉ chấp nhận hai thao tác add/prefix, nên lời giải bắt buộc dùng cây Fenwick (BIT). Bạn phải cài đặt lời giải này bằng Python (ngôn ngữ chính của bài).\r\n\\end{itemize}\r\n\r\n\r\n\\textbf{Subtasks.}\r\n\\begin{itemize}\r\n  \\item \\textbf{Subtask 1 (20 điểm):} $H, W \\le 10^{12}$, $n \\le 9\\,696$.\r\n  \\item \\textbf{Subtask 2 (30 điểm):} $H, W \\le 10^{12}$, $n \\le 363\\,636$.\r\n  \\item \\textbf{Subtask 3 (50 điểm):} $H, W \\le 10^{12}$, $n \\le 969\\,696$.\r\n\\end{itemize}\r\n","legend":"Cục điều phối bộ nhớ của Bộ Quốc Phòng đang thử nghiệm chip giám sát \"Fenrir\". Fenrir được hàn thẳng vào bus bộ nhớ và tự động duy trì \\emph{các tổng tiền tố} cho từng cột trong lưới nhớ. Lớp firmware bảo mật của Fenrir chỉ cung cấp đúng hai lệnh phần cứng: \\texttt{inc(c, k)} (cộng thêm $k$ tiến trình vào cột $c$) và \\texttt{pref(c)} (trả về tổng số tiến trình hiện diện trong các cột từ $1$ tới $c$). Bất kỳ thuật toán nào đòi hỏi truy cập ngẫu nhiên hay cấu trúc dữ liệu khác (ví dụ segment tree) đều bị khóa và báo lỗi \"không tương thích giao diện\". Nghĩa là mọi xử lý số lượng tiến trình trên các đoạn cột liên tiếp đều buộc phải ghép lời giải vào các lệnh Fenrir -- chính là Fenwick tree.\r\n\r\nBộ nhớ vật lý của hệ thống là một lưới $H \\times W$ (đánh số hàng, cột từ $1$). Có $n$ tiến trình đã chiếm các ô $(r_i, c_i)$ và danh sách này được cập nhật liên tục qua chuẩn Fenrir. Mỗi đêm, Tổng trạm yêu cầu báo cáo \"phân mảnh\": hãy đặt đúng một đường cắt ngang giữa hai hàng liên tiếp và một đường cắt dọc giữa hai cột liên tiếp để chia lưới thành bốn miền chữ nhật. Chi phí của cấu hình là số tiến trình lớn nhất nằm trong một miền (họ sẽ chuyển tiến trình ra khỏi miền \"đông dân nhất\" để tái cân bằng). Nhiệm vụ của bạn là chọn vị trí hai đường cắt sao cho chi phí nhỏ nhất có thể, tuân thủ ràng buộc truy vấn/ cập nhật đúng định dạng Fenrir.\r\n","authorLogin":"uraqt","language":"vietnamese","timeLimit":5000,"output":"In ra một số nguyên duy nhất là số tiến trình lớn nhất trong bốn miền sau khi chọn hai đường cắt tối ưu.\r\n","inputFile":"stdin","outputFile":"stdout","input":"\\begin{itemize}\r\n  \\item Dòng đầu chứa hai số nguyên $H$, $W$ ($1 \\le H, W \\le 10^{12}$).\r\n  \\item Dòng thứ hai chứa số nguyên $n$ ($0 \\le n \\le 969\\,696$).\r\n  \\item Mỗi dòng trong $n$ dòng tiếp theo chứa hai số nguyên $r_i$, $c_i$ ($1 \\le r_i \\le H$, $1 \\le c_i \\le W$) --- tọa độ ô đã bị chiếm.\r\n\\end{itemize}","authorName":"Trung Le","sampleTests":[{"output":"2\r\n","input":"20 20\r\n7\r\n7 3\r\n5 5\r\n7 13\r\n3 1\r\n11 7\r\n5 3\r\n9 1\r\n","inputFile":"example.01","outputFile":"example.01.a"}],"name":"Phân vùng bộ nhớ hệ điều hành","interaction":null,"memoryLimit":536870912,"tutorial":"Nén độc lập toàn bộ tọa độ hàng và cột để thu được tối đa $2 \\cdot 10^5$ vị trí. Sắp xếp các điểm theo hàng; khi quét từ dưới lên, dùng hai Fenwick tree (hoặc segment tree) để lưu số tiến trình phía trên và phía dưới đường cắt ngang hiện tại. Với mỗi vị trí ngang, cần tìm cột để đặt đường cắt dọc sao cho số tiến trình ở hai miền bên trái không vượt quá bên phải. Có thể áp dụng tìm kiếm nhị phân hoặc binary lifting trên Fenwick tree để xác định cột đó và cập nhật đáp án bằng giá trị lớn nhất trong bốn miền. Lặp lại cho mọi khoảng giữa các hàng (kể cả biên) để lấy giá trị nhỏ nhất thu được.\r\n"}